---
phase: 02-transcription-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/paste/mod.rs
  - src-tauri/src/paste/clipboard.rs
  - src-tauri/src/paste/simulate.rs
  - src-tauri/src/paste/permissions.rs
  - src-tauri/capabilities/default.json
autonomous: true

must_haves:
  truths:
    - "Text can be written to system clipboard"
    - "Original clipboard content can be preserved and restored"
    - "Keyboard simulation can trigger Cmd+V paste"
    - "Accessibility permission status can be checked"
    - "System notification can be shown for fallback"
  artifacts:
    - path: "src-tauri/src/paste/mod.rs"
      provides: "Module exports for paste subsystem"
      exports: ["ClipboardGuard", "simulate_paste", "check_accessibility"]
    - path: "src-tauri/src/paste/clipboard.rs"
      provides: "Clipboard read/write with preservation"
      contains: "ClipboardGuard"
      min_lines: 30
    - path: "src-tauri/src/paste/simulate.rs"
      provides: "Keyboard simulation for Cmd+V"
      contains: "Key::Meta"
      min_lines: 20
    - path: "src-tauri/src/paste/permissions.rs"
      provides: "macOS accessibility permission check"
      contains: "checkAccessibilityPermission"
      min_lines: 10
  key_links:
    - from: "src-tauri/src/paste/clipboard.rs"
      to: "tauri_plugin_clipboard_manager"
      via: "ClipboardExt trait"
      pattern: "clipboard\\(\\)"
    - from: "src-tauri/src/paste/simulate.rs"
      to: "enigo"
      via: "Keyboard trait"
      pattern: "enigo::.*Key"
---

<objective>
Create the paste simulation and clipboard management modules for auto-pasting text.

Purpose: These modules handle the output stage — putting polished text into the user's active application via keyboard simulation, with clipboard fallback when auto-paste fails.

Output: Rust modules for clipboard operations (preserve/write/restore), keyboard simulation (Cmd+V), and accessibility permission checking.
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-transcription-pipeline/02-RESEARCH.md
@.planning/phases/02-transcription-pipeline/02-CONTEXT.md
@src-tauri/src/lib.rs
@src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add paste dependencies and create module structure</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/paste/mod.rs
    src-tauri/capabilities/default.json
  </files>
  <action>
Add required dependencies to Cargo.toml:
- `tauri-plugin-clipboard-manager` version "2" (for clipboard read/write)
- `tauri-plugin-notification` version "2" (for fallback notifications)
- `enigo` version "0.2" (for keyboard simulation)

Note: tauri-plugin-macos-permissions is NOT available as a Cargo crate — it's JavaScript-only. We'll check accessibility via enigo's behavior instead (try paste, catch error).

Create `src-tauri/src/paste/mod.rs` that exports:
```rust
pub mod clipboard;
pub mod simulate;
pub mod permissions;

pub use clipboard::ClipboardGuard;
pub use simulate::simulate_paste;
pub use permissions::check_accessibility;
```

Update `src-tauri/capabilities/default.json` to add permissions:
- `clipboard-manager:allow-read-text`
- `clipboard-manager:allow-write-text`
- `notification:default`

Add the plugins to lib.rs setup (just init, not commands yet).
  </action>
  <verify>
`cargo check` passes with new dependencies. The paste module structure exists.
  </verify>
  <done>
Dependencies added (clipboard, notification, enigo), module structure created, capabilities configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement clipboard preservation and management</name>
  <files>
    src-tauri/src/paste/clipboard.rs
  </files>
  <action>
Create `src-tauri/src/paste/clipboard.rs` with ClipboardGuard pattern from research:

1. Struct `ClipboardGuard` that holds:
   - `original_content: Option<String>` — saved clipboard text
   - `app: AppHandle` — for clipboard access

2. Implementation:
   - `new(app: &AppHandle) -> Self`: Save current clipboard content via `app.clipboard().read_text()`
   - `write_text(&self, text: &str) -> Result<(), String>`: Write new text to clipboard
   - `restore(self) -> Result<(), String>`: Restore original content if it existed

Per CONTEXT.md: "clipboard to always have the transcription as backup" — we write text to clipboard BEFORE paste attempt, and only restore on SUCCESS. On failure, text stays in clipboard for manual paste.

Import `tauri_plugin_clipboard_manager::ClipboardExt` for the clipboard() method.

Error messages:
- "Failed to read clipboard: {error}"
- "Failed to write to clipboard: {error}"
- "Failed to restore clipboard: {error}"
  </action>
  <verify>
`cargo check` passes. ClipboardGuard struct has new(), write_text(), restore() methods.
  </verify>
  <done>
ClipboardGuard implemented with save/write/restore pattern. Text goes to clipboard before paste attempt.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement keyboard simulation and permission checking</name>
  <files>
    src-tauri/src/paste/simulate.rs
    src-tauri/src/paste/permissions.rs
  </files>
  <action>
Create `src-tauri/src/paste/simulate.rs`:

1. Function `simulate_paste() -> Result<(), String>`:
   - Create Enigo instance with default settings
   - Small delay (50ms) to ensure app focus
   - Press Meta key (Cmd on macOS)
   - Click 'v' key
   - Release Meta key
   - Return Ok(()) on success

Use enigo types:
- `enigo::{Enigo, Key, Keyboard, Settings, Direction}`

Error handling:
- "Failed to create enigo: {error}"
- "Failed to simulate paste: {error}"

Create `src-tauri/src/paste/permissions.rs`:

Since tauri-plugin-macos-permissions isn't a Rust crate, implement permission check via enigo behavior:

1. Function `check_accessibility() -> bool`:
   - Try to create Enigo instance
   - If creation succeeds, return true
   - If creation fails (permission error), return false

This is a practical approach — enigo will fail to initialize without accessibility permission.

Alternative: We can also just try the paste and catch the error in the pipeline. Document this tradeoff.
  </action>
  <verify>
`cargo check` passes. simulate_paste() and check_accessibility() functions exist.
  </verify>
  <done>
Keyboard simulation (Cmd+V) implemented with enigo. Permission check implemented via enigo initialization test.
  </done>
</task>

</tasks>

<verification>
All verification for this plan:

1. `cargo check` passes with no errors
2. `src-tauri/src/paste/` directory exists with mod.rs, clipboard.rs, simulate.rs, permissions.rs
3. Cargo.toml contains tauri-plugin-clipboard-manager, tauri-plugin-notification, enigo dependencies
4. capabilities/default.json has clipboard and notification permissions
5. ClipboardGuard preserves and restores clipboard content
</verification>

<success_criteria>
- Clipboard operations work (read, write, restore)
- Keyboard simulation can send Cmd+V
- Accessibility permission can be checked (at least via enigo init)
- No manual testing required — this is backend infrastructure
</success_criteria>

<output>
After completion, create `.planning/phases/02-transcription-pipeline/02-02-SUMMARY.md`
</output>
