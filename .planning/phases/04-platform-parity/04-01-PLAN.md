---
phase: 04-platform-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/paste/simulate.rs
  - src-tauri/src/shortcuts.rs
  - src-tauri/src/settings/store.rs
  - src-tauri/src/lib.rs
  - src/stores/settings-store.ts
  - src/windows/Settings.tsx
autonomous: true

must_haves:
  truths:
    - "Paste simulation works on both macOS and Windows"
    - "User can change the global shortcut in settings"
    - "Changed shortcut persists across app restarts"
    - "Shortcut conflicts are handled gracefully"
  artifacts:
    - path: "src-tauri/src/paste/simulate.rs"
      provides: "Cross-platform paste using enigo"
      contains: "cfg(target_os"
    - path: "src-tauri/src/shortcuts.rs"
      provides: "Dynamic shortcut registration with update_shortcut function"
      contains: "unregister"
    - path: "src-tauri/src/settings/store.rs"
      provides: "Settings with shortcut field"
      contains: "shortcut"
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri command export for update_shortcut"
      contains: "update_shortcut"
  key_links:
    - from: "src/windows/Settings.tsx"
      to: "settings store"
      via: "invoke set_settings with shortcut"
      pattern: "set_settings.*shortcut"
    - from: "src-tauri/src/shortcuts.rs"
      to: "settings"
      via: "get_settings() call at start of setup_shortcuts"
      pattern: "get_settings\\(\\)"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/shortcuts.rs"
      via: "update_shortcut_cmd calls shortcuts::update_shortcut"
      pattern: "shortcuts::update_shortcut"
---

<objective>
Cross-platform paste simulation and customizable keyboard shortcuts

Purpose: Ensure paste works on Windows (currently macOS-only via AppleScript) and allow users to customize their recording shortcut (CFG-04 requirement). This is the core feature parity work for Phase 4.

Output: Modified paste/simulate.rs using enigo for both platforms, updated shortcuts.rs with dynamic registration, settings with shortcut field, and Settings UI with shortcut customization.

Note on macOS Accessibility Permission: When enigo attempts keyboard simulation on macOS, the system automatically prompts the user to grant Accessibility permission to the app. This is standard macOS behavior - no additional code is needed. The first time paste simulation runs, users will see the system permission dialog. Once granted, it persists until the app is removed from the Accessibility list.
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-platform-parity/04-RESEARCH.md

# Relevant prior work
@.planning/phases/02-transcription-pipeline/02-02-SUMMARY.md (paste infrastructure)
@.planning/phases/03-learning-settings/03-02-SUMMARY.md (settings pattern)

# Source files to modify
@src-tauri/src/paste/simulate.rs
@src-tauri/src/shortcuts.rs
@src-tauri/src/settings/store.rs
@src-tauri/src/lib.rs
@src/stores/settings-store.ts
@src/windows/Settings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace AppleScript paste with cross-platform enigo</name>
  <files>src-tauri/src/paste/simulate.rs</files>
  <action>
Replace the current AppleScript-based paste simulation with enigo, which is already in dependencies.

Implementation:
1. Remove the std::process::Command import and osascript call
2. Use enigo with conditional compilation for macOS (Meta+V) vs Windows (Control+V)
3. Use enigo::Direction::{Press, Click, Release} for key sequence
4. Keep the 100ms delay before paste

Pattern from 04-RESEARCH.md:
```rust
use enigo::{Enigo, Key, Keyboard, Settings, Direction::{Press, Click, Release}};

pub fn simulate_paste() -> Result<(), String> {
    std::thread::sleep(std::time::Duration::from_millis(100));

    let mut enigo = Enigo::new(&Settings::default())
        .map_err(|e| format!("Failed to create Enigo: {}", e))?;

    #[cfg(target_os = "macos")]
    {
        enigo.key(Key::Meta, Press).map_err(|e| e.to_string())?;
        enigo.key(Key::Unicode('v'), Click).map_err(|e| e.to_string())?;
        enigo.key(Key::Meta, Release).map_err(|e| e.to_string())?;
    }

    #[cfg(target_os = "windows")]
    {
        enigo.key(Key::Control, Press).map_err(|e| e.to_string())?;
        enigo.key(Key::Unicode('v'), Click).map_err(|e| e.to_string())?;
        enigo.key(Key::Control, Release).map_err(|e| e.to_string())?;
    }

    Ok(())
}
```

NOTE: enigo is already in Cargo.toml (version 0.2), no dependency changes needed.

NOTE: On macOS, when enigo first attempts keyboard simulation, the system will automatically prompt the user to grant Accessibility permission. This is standard OS behavior and requires no additional code.
  </action>
  <verify>
cargo check passes with no errors.
Build for current platform: `cd src-tauri && cargo build`
  </verify>
  <done>simulate_paste() uses enigo with platform-conditional key sequences (Meta for macOS, Control for Windows)</done>
</task>

<task type="auto">
  <name>Task 2: Add shortcut customization to settings and implement dynamic registration</name>
  <files>
src-tauri/src/settings/store.rs
src-tauri/src/shortcuts.rs
src-tauri/src/lib.rs
  </files>
  <action>
Add shortcut field to Settings struct and implement dynamic shortcut registration.

**Settings store changes (store.rs):**
1. Add `shortcut: String` field to Settings struct with default "Alt+Space"
2. Default::default() sets shortcut to "Alt+Space"
3. No other changes needed - existing get_settings/set_settings handle serialization

**Shortcuts module changes (shortcuts.rs):**
1. Import settings::store::get_settings at top of file
2. Add `update_shortcut(app: &AppHandle, new_shortcut: &str) -> Result<(), String>` function:
   - Parse new_shortcut string to Shortcut using `.parse::<Shortcut>()`
   - Get global_shortcut manager from app
   - Check if already registered with is_registered()
   - Unregister old shortcut if exists
   - Register new shortcut with on_shortcut handler
   - Return error if shortcut is invalid or already in use by another app
3. Modify setup_shortcuts() to load shortcut from settings on startup:
   - At the START of setup_shortcuts(), add: `let settings = get_settings();`
   - Parse settings.shortcut string to get the shortcut to register
   - If parsing fails, fall back to default "Alt+Space"
   - Use the parsed shortcut instead of hardcoded "Alt+Space"

**lib.rs changes:**
1. Add update_shortcut as a Tauri command export
2. Create wrapper function:
   ```rust
   #[tauri::command]
   fn update_shortcut_cmd(app: AppHandle, shortcut: String) -> Result<(), String> {
       shortcuts::update_shortcut(&app, &shortcut)
   }
   ```
3. Add `update_shortcut_cmd` to the .invoke_handler(tauri::generate_handler![...]) list

Shortcut string format follows Tauri convention: "Alt+Space", "Ctrl+Shift+R", "CmdOrCtrl+Space"
  </action>
  <verify>
cargo check passes.
Build succeeds: `cd src-tauri && cargo build`
  </verify>
  <done>Settings has shortcut field, setup_shortcuts loads from settings via get_settings() at startup, update_shortcut function enables runtime changes, lib.rs exports update_shortcut_cmd</done>
</task>

<task type="auto">
  <name>Task 3: Add shortcut customization UI to Settings window</name>
  <files>
src/stores/settings-store.ts
src/windows/Settings.tsx
  </files>
  <action>
Add shortcut field to frontend settings and UI for customization.

**settings-store.ts changes:**
1. Add `shortcut: string` to Settings interface with default "Alt+Space"
2. Update fetchSettings to include shortcut
3. Update setSettings to include shortcut

**Settings.tsx changes:**
1. Add shortcut input section after AI Polish toggle
2. Use a text input for shortcut (simple approach - user types "Alt+Space", "Ctrl+Shift+R", etc.)
3. Add "Apply" button next to shortcut input that:
   - Calls `invoke('update_shortcut_cmd', { shortcut: newShortcut })`
   - On success: update settings store and show success message
   - On error: show error toast (shortcut invalid or in use)
4. Display current shortcut with helper text explaining format
5. Add section header "Keyboard Shortcut" with description "Press and hold to record (push-to-talk), or double-tap to toggle recording"

Layout:
```
[Keyboard Shortcut]
Current: Alt+Space
[text input: Alt+Space] [Apply]
Format: Alt+Space, Ctrl+Shift+R, CmdOrCtrl+Space

[AI Polish]
...rest of settings...
```

Keep it simple - no fancy keyboard capture, just text input with format guidance.
  </action>
  <verify>
npm run build succeeds.
Dev server runs: `npm run tauri dev` - Settings window shows shortcut section.
  </verify>
  <done>Settings window has shortcut customization with text input and Apply button</done>
</task>

</tasks>

<verification>
1. `cargo check` in src-tauri passes
2. `npm run build` succeeds
3. `npm run tauri dev` launches app
4. Settings window shows shortcut customization section
5. Changing shortcut and clicking Apply updates the active shortcut
6. New shortcut persists after app restart
7. On macOS: First paste triggers Accessibility permission dialog (system behavior)
</verification>

<success_criteria>
- Paste simulation uses enigo with platform-conditional compilation (macOS=Meta, Windows=Control)
- Settings includes shortcut field with default "Alt+Space"
- setup_shortcuts() loads shortcut from settings via get_settings() on startup
- update_shortcut() enables runtime shortcut changes
- lib.rs exports update_shortcut_cmd Tauri command
- Settings UI allows users to change shortcut with immediate feedback
- Requirements addressed: CFG-04 (customizable shortcut), PLT-03 partial (paste parity)
</success_criteria>

<output>
After completion, create `.planning/phases/04-platform-parity/04-01-SUMMARY.md`
</output>
