---
phase: 01-foundation-recording
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/recording.rs
  - src-tauri/src/credentials.rs
  - src-tauri/src/shortcuts.rs
  - src-tauri/capabilities/default.json
  - src/windows/ApiKeySetup.tsx
  - src/components/ApiKeyForm.tsx
  - src/App.tsx
  - src/main.tsx
autonomous: false

user_setup:
  - service: openai
    why: "Whisper API for transcription (Phase 2), but key collected now"
    env_vars:
      - name: OPENAI_API_KEY
        source: "OpenAI Platform -> API keys -> Create new secret key"
    dashboard_config: []

must_haves:
  truths:
    - "User is prompted for API key on first launch"
    - "User can enter and save API key securely"
    - "API key is stored in system keychain"
    - "Subsequent launches skip API key prompt if key exists"
    - "Recording captures audio from default microphone"
    - "Audio is saved as WAV file for later transcription"
  artifacts:
    - path: "src-tauri/src/credentials.rs"
      provides: "Secure API key storage via system keychain"
      contains: "tauri_plugin_keyring"
    - path: "src-tauri/src/recording.rs"
      provides: "Audio capture from microphone"
      contains: "tauri-plugin-mic-recorder"
    - path: "src/windows/ApiKeySetup.tsx"
      provides: "First-run API key setup window"
      min_lines: 40
    - path: "src/components/ApiKeyForm.tsx"
      provides: "API key input form component"
      contains: "setPassword"
  key_links:
    - from: "src/components/ApiKeyForm.tsx"
      to: "src-tauri/src/credentials.rs"
      via: "Tauri command invocation"
      pattern: "invoke.*set_api_key"
    - from: "src-tauri/src/shortcuts.rs"
      to: "src-tauri/src/recording.rs"
      via: "start/stop recording on state change"
      pattern: "start_mic_recording|stop_mic_recording"
    - from: "src-tauri/src/recording.rs"
      to: "file system"
      via: "WAV file output"
      pattern: "\\.wav"
---

<objective>
Implement audio capture from microphone and secure API key storage with first-run setup flow.

Purpose: Complete the recording capability and prepare for Phase 2 transcription. Users need their API key stored securely, and recordings need to produce audio files that can be sent to Whisper.

Output: Working audio recording that produces WAV files, secure credential storage, and first-run API key setup UI.
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-recording/01-RESEARCH.md
@.planning/phases/01-foundation-recording/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement secure API key storage with keyring</name>
  <files>
    src-tauri/src/credentials.rs
    src-tauri/src/lib.rs
    src-tauri/capabilities/default.json
  </files>
  <action>
    1. Create src-tauri/src/credentials.rs:
       ```rust
       use tauri::Manager;
       use tauri_plugin_keyring::KeyringExt;

       const SERVICE_NAME: &str = "TTP";
       const API_KEY_USER: &str = "openai-api-key";

       #[tauri::command]
       pub async fn get_api_key(app: tauri::AppHandle) -> Result<Option<String>, String> {
           app.keyring()
               .get_password(SERVICE_NAME, API_KEY_USER)
               .map_err(|e| e.to_string())
       }

       #[tauri::command]
       pub async fn set_api_key(app: tauri::AppHandle, key: String) -> Result<(), String> {
           app.keyring()
               .set_password(SERVICE_NAME, API_KEY_USER, &key)
               .map_err(|e| e.to_string())
       }

       #[tauri::command]
       pub async fn has_api_key(app: tauri::AppHandle) -> Result<bool, String> {
           let result = app.keyring()
               .get_password(SERVICE_NAME, API_KEY_USER)
               .map_err(|e| e.to_string())?;
           Ok(result.is_some())
       }

       #[tauri::command]
       pub async fn delete_api_key(app: tauri::AppHandle) -> Result<(), String> {
           app.keyring()
               .delete_password(SERVICE_NAME, API_KEY_USER)
               .map_err(|e| e.to_string())
       }
       ```

    2. Update src-tauri/src/lib.rs:
       - Declare credentials module
       - Register commands: get_api_key, set_api_key, has_api_key, delete_api_key
       - Add commands to invoke_handler

    3. Update src-tauri/capabilities/default.json:
       - Add keyring permissions if required by the plugin

    AVOID: Do not store API key in plain text files or localStorage.
    AVOID: Do not log the API key value anywhere.
  </action>
  <verify>
    - `cargo check --manifest-path src-tauri/Cargo.toml` passes
    - Run app, invoke set_api_key from dev console, then has_api_key returns true
    - Restart app, has_api_key still returns true (persisted in keychain)
  </verify>
  <done>
    - Credential commands exposed to frontend
    - API key stored in system keychain (macOS Keychain / Windows Credential Manager)
    - get/set/has/delete operations functional
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement audio recording with mic-recorder plugin</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/recording.rs
    src-tauri/src/shortcuts.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    1. Add tauri-plugin-mic-recorder to Cargo.toml:
       ```toml
       [dependencies]
       tauri-plugin-mic-recorder = "2"
       ```

    2. Create src-tauri/src/recording.rs:
       ```rust
       use std::path::PathBuf;
       use tauri::Manager;

       // Store the current recording path
       pub struct RecordingContext {
           pub current_file: Option<PathBuf>,
       }

       impl Default for RecordingContext {
           fn default() -> Self {
               Self { current_file: None }
           }
       }

       pub fn get_recording_dir(app: &tauri::AppHandle) -> PathBuf {
           app.path().app_data_dir()
               .expect("Failed to get app data dir")
               .join("recordings")
       }

       pub fn generate_recording_path(app: &tauri::AppHandle) -> PathBuf {
           let dir = get_recording_dir(app);
           std::fs::create_dir_all(&dir).ok();
           let timestamp = chrono::Utc::now().format("%Y%m%d_%H%M%S");
           dir.join(format!("recording_{}.wav", timestamp))
       }
       ```

    3. Add chrono dependency to Cargo.toml:
       ```toml
       chrono = "0.4"
       ```

    4. Install frontend package:
       ```bash
       npm install tauri-plugin-mic-recorder-api
       ```

    5. Update src-tauri/src/shortcuts.rs:
       - Import recording module
       - In start_recording():
         - Generate recording path
         - Start mic recording via plugin
         - Store path in RecordingContext
       - In stop_recording():
         - Stop mic recording via plugin
         - Log the output file path (for Phase 2 to use)

       Note: The mic-recorder plugin is controlled from JavaScript side.
       Rust side just manages paths and state.

    6. Update src-tauri/src/lib.rs:
       - Register tauri_plugin_mic_recorder
       - Add RecordingContext as managed state

    7. Create frontend recording control (temporary, for this phase):
       - The mic-recorder plugin API is:
         ```typescript
         import { startRecording, stopRecording } from 'tauri-plugin-mic-recorder-api';
         await startRecording(); // starts recording
         const filePath = await stopRecording(); // returns WAV file path
         ```
       - Emit events from Rust to trigger these from frontend
       - Or use Tauri commands to invoke JS

    AVOID: Do not use browser MediaRecorder API - use native recording via plugin.
    AVOID: Do not keep recordings indefinitely - Phase 3 will add cleanup.
  </action>
  <verify>
    - `cargo check --manifest-path src-tauri/Cargo.toml` passes
    - `npm run tauri dev` runs without errors
    - Hold Ctrl+Shift+Space, speak, release
    - Check app data directory for WAV file
    - WAV file contains audible audio (play with any audio player)
  </verify>
  <done>
    - mic-recorder plugin integrated
    - Recording produces WAV file in app data directory
    - File path available for Phase 2 transcription
    - Recording starts/stops with shortcut
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API key setup UI for first run</name>
  <files>
    src/windows/ApiKeySetup.tsx
    src/components/ApiKeyForm.tsx
    src/main.tsx
    src/App.tsx
    src-tauri/tauri.conf.json
  </files>
  <action>
    1. Create src/components/ApiKeyForm.tsx:
       ```tsx
       import { useState } from 'react';
       import { invoke } from '@tauri-apps/api/core';

       interface Props {
         onSuccess: () => void;
       }

       export function ApiKeyForm({ onSuccess }: Props) {
         const [apiKey, setApiKey] = useState('');
         const [error, setError] = useState('');
         const [loading, setLoading] = useState(false);

         const handleSubmit = async (e: React.FormEvent) => {
           e.preventDefault();
           if (!apiKey.startsWith('sk-')) {
             setError('API key should start with "sk-"');
             return;
           }
           setLoading(true);
           try {
             await invoke('set_api_key', { key: apiKey });
             onSuccess();
           } catch (err) {
             setError(String(err));
           } finally {
             setLoading(false);
           }
         };

         return (
           <form onSubmit={handleSubmit} className="space-y-4">
             <div>
               <label className="block text-sm font-medium mb-1">
                 OpenAI API Key
               </label>
               <input
                 type="password"
                 value={apiKey}
                 onChange={(e) => setApiKey(e.target.value)}
                 placeholder="sk-..."
                 className="w-full px-3 py-2 border rounded-lg"
               />
             </div>
             {error && <p className="text-red-500 text-sm">{error}</p>}
             <button
               type="submit"
               disabled={loading || !apiKey}
               className="w-full py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50"
             >
               {loading ? 'Saving...' : 'Save API Key'}
             </button>
             <p className="text-xs text-gray-500">
               Get your API key from{' '}
               <a href="https://platform.openai.com/api-keys"
                  className="text-blue-500 underline"
                  target="_blank">
                 OpenAI Platform
               </a>
             </p>
           </form>
         );
       }
       ```

    2. Create src/windows/ApiKeySetup.tsx:
       ```tsx
       import { ApiKeyForm } from '../components/ApiKeyForm';
       import { getCurrentWindow } from '@tauri-apps/api/window';

       export function ApiKeySetup() {
         const handleSuccess = async () => {
           // Close setup window after successful save
           const window = getCurrentWindow();
           await window.close();
         };

         return (
           <div className="p-6 max-w-md mx-auto">
             <h1 className="text-xl font-bold mb-4">Welcome to TTP</h1>
             <p className="text-gray-600 mb-6">
               TTP uses OpenAI's Whisper API for transcription.
               Enter your API key to get started.
             </p>
             <ApiKeyForm onSuccess={handleSuccess} />
           </div>
         );
       }
       ```

    3. Update src-tauri/tauri.conf.json to add setup window:
       ```json
       {
         "label": "setup",
         "title": "TTP Setup",
         "width": 400,
         "height": 350,
         "resizable": false,
         "visible": false,
         "center": true
       }
       ```

    4. Update src/main.tsx to route to correct window:
       - Check window label
       - If "setup": render ApiKeySetup
       - If "floating-bar": render FloatingBar
       - Otherwise: render App (or nothing for main hidden window)

    5. Update app startup logic in src-tauri/src/lib.rs:
       - In setup hook, after tray is created:
         ```rust
         // Check if API key exists
         let has_key = app.keyring()
             .get_password("TTP", "openai-api-key")
             .map(|k| k.is_some())
             .unwrap_or(false);

         if !has_key {
             // Show setup window
             if let Some(window) = app.get_webview_window("setup") {
                 let _ = window.show();
                 let _ = window.set_focus();
             }
         }
         ```

    6. Update src/App.tsx:
       - Make it minimal (hidden window for tray-only app)
       - Could just render empty div or null

    AVOID: Do not validate API key against OpenAI API yet - just format check.
    AVOID: Do not block app startup on API key - just show setup window.
  </action>
  <verify>
    - Clear any existing API key (or fresh install)
    - `npm run tauri dev` - setup window appears automatically
    - Enter valid-looking API key (sk-...), click Save
    - Window closes, tray icon remains
    - Restart app - setup window does NOT appear (key exists)
    - Shortcuts still work after API key is set
  </verify>
  <done>
    - First-run experience shows API key setup
    - API key saved to system keychain
    - Subsequent runs skip setup if key exists
    - Clean, user-friendly setup UI
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1: Foundation + Recording
    - Tray app with global shortcuts (Ctrl+Shift+Space)
    - Push-to-talk and double-tap toggle modes
    - Floating bar visual feedback during recording
    - Sound effects for start/stop
    - Audio capture producing WAV files
    - First-run API key setup with secure storage
  </what-built>
  <how-to-verify>
    1. Fresh start (clear any saved API key if testing):
       - Run `npm run tauri dev`
       - API key setup window should appear
       - Enter a test API key (sk-test123...) and save
       - Window should close

    2. Recording test:
       - Hold Ctrl+Shift+Space
       - Verify: Start sound plays, floating bar appears
       - Speak a few words into microphone
       - Release shortcut
       - Verify: Stop sound plays, floating bar disappears

    3. Double-tap test:
       - Quickly double-tap Ctrl+Shift+Space
       - Verify: Enters hands-free mode (bar stays visible)
       - Tap Ctrl+Shift+Space once
       - Verify: Exits hands-free mode (bar hides)

    4. Persistence test:
       - Quit app from tray menu
       - Restart with `npm run tauri dev`
       - Verify: Setup window does NOT appear (key persisted)
       - Verify: Shortcuts still work

    5. Check recording file:
       - Look in app data directory for recordings folder
       - Play the WAV file - should contain your speech
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. API key can be saved and retrieved from keychain
2. First-run setup window appears when no API key exists
3. Recording produces valid WAV files with captured audio
4. All Phase 1 success criteria from ROADMAP are met:
   - User sees app icon in menu bar/tray
   - Push-to-talk with shortcut works
   - Double-tap toggle works
   - Visual indicator shows during recording
   - API key prompt on first run, stored securely
</verification>

<success_criteria>
- API key securely stored in system keychain
- First-run API key setup flow is complete and user-friendly
- Audio recording captures microphone input to WAV file
- WAV files are saved with timestamps in app data directory
- Recording integrates with existing shortcut/state system
- All shortcuts, floating bar, and sounds still work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-recording/01-03-SUMMARY.md`
</output>
