---
phase: 05-ensemble-transcription
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/settings/store.rs
  - src-tauri/src/transcription/ensemble.rs
  - src-tauri/src/transcription/mod.rs
autonomous: true

must_haves:
  truths:
    - "Settings struct has ensemble_enabled field"
    - "Parallel provider execution calls all available providers"
    - "Individual provider failures do not block ensemble"
  artifacts:
    - path: "src-tauri/src/settings/store.rs"
      provides: "ensemble_enabled setting field"
      contains: "ensemble_enabled"
    - path: "src-tauri/src/transcription/ensemble.rs"
      provides: "Parallel transcription with graceful degradation"
      exports: ["transcribe_ensemble", "ProviderResult"]
  key_links:
    - from: "src-tauri/src/transcription/ensemble.rs"
      to: "transcribe_audio, transcribe_audio_gladia"
      via: "function imports"
      pattern: "use super::"
---

<objective>
Create the foundation for ensemble transcription: backend settings field and parallel provider execution module.

Purpose: Enable parallel transcription across multiple providers (Groq, Gladia, OpenAI) with graceful degradation when individual providers fail.
Output: Settings with ensemble_enabled field, ensemble.rs module with parallel execution logic.
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ensemble-transcription/05-RESEARCH.md

# Existing implementation
@src-tauri/src/settings/store.rs
@src-tauri/src/transcription/mod.rs
@src-tauri/src/transcription/whisper.rs
@src-tauri/src/transcription/gladia.rs
@src-tauri/src/credentials.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ensemble_enabled to Settings struct</name>
  <files>src-tauri/src/settings/store.rs</files>
  <action>
Add `ensemble_enabled: bool` field to the Settings struct with:
- Field with `#[serde(default)]` attribute (defaults to false for backward compatibility)
- Add to Default impl: `ensemble_enabled: false`
- No other changes needed - get_settings and set_settings already handle full struct

The field should be placed after `transcription_provider` in the struct definition.
  </action>
  <verify>
Run `cargo check -p ttp` to verify the struct compiles.
Verify serde derives work: the existing JSON will deserialize with ensemble_enabled defaulting to false.
  </verify>
  <done>Settings struct has ensemble_enabled: bool field that defaults to false and serializes correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create ensemble.rs with parallel provider execution</name>
  <files>src-tauri/src/transcription/ensemble.rs, src-tauri/src/transcription/mod.rs</files>
  <action>
Create `src-tauri/src/transcription/ensemble.rs` with:

1. **ProviderResult struct:**
```rust
#[derive(Debug, Clone)]
pub struct ProviderResult {
    pub provider: String,
    pub text: String,
    pub latency_ms: u64,
}
```

2. **transcribe_ensemble function:**
- Takes `audio_path: &str` and optional API keys for each provider (openai_key, groq_key, gladia_key)
- Uses `futures::future::join_all` to run all available providers in parallel
- Wraps each provider call in `tokio::time::timeout` (30 seconds - Gladia can be slow)
- Returns `Result<Vec<ProviderResult>, String>` - success if at least one provider succeeds
- Log each provider's result (success/failure/timeout) to console

Key patterns from RESEARCH.md:
- Use existing `transcribe_audio` for OpenAI and Groq (whisper.rs handles both via different base URLs)
- Use `transcribe_audio_gladia` for Gladia
- Continue with partial results - don't fail on individual provider errors
- Empty results or errors are logged and skipped, not propagated

3. **Update mod.rs:**
- Add `pub mod ensemble;`
- Add `pub use ensemble::{transcribe_ensemble, ProviderResult};`

Note: The whisper.rs transcribe_audio function uses the GROQ_API_URL or OPENAI_API_URL based on provider setting. For ensemble, we need to call the right provider explicitly. Check how transcribe_audio determines which URL to use and adapt accordingly. You may need to add provider-specific transcription functions or pass the base URL.
  </action>
  <verify>
Run `cargo check -p ttp` to verify compilation.
Run `cargo test -p ttp` if tests exist.
Verify mod.rs exports are correct.
  </verify>
  <done>
ensemble.rs exists with transcribe_ensemble function that:
- Accepts optional API keys for each provider
- Executes available providers in parallel using join_all
- Uses 30s timeout per provider
- Returns Vec of ProviderResult (at least 1 result required for success)
- Logs provider status to console
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p ttp` succeeds
2. Settings with ensemble_enabled field serializes/deserializes correctly
3. ensemble.rs compiles and exports ProviderResult and transcribe_ensemble
</verification>

<success_criteria>
- Settings struct has ensemble_enabled: bool defaulting to false
- ensemble.rs exists with ProviderResult type and transcribe_ensemble function
- All providers can be called in parallel with graceful failure handling
- Module is properly exported from transcription/mod.rs
</success_criteria>

<output>
After completion, create `.planning/phases/05-ensemble-transcription/05-01-SUMMARY.md`
</output>
